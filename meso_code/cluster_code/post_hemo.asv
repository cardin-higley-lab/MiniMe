function post_hemo(id_date_time, norm_method)
 
% id_date_time = 'SP_MouseF_0820_pre';
% norm_method = 'dff';

addpath(genpath('../MesoProcessing-master'))

run('../defineIODirs.m'); % input and output directories
findslash = strfind(id_date_time,'_');
project = id_date_time(1:findslash(1)-1);
mouseID = id_date_time(findslash(1)+1:findslash(2)-1);
date = id_date_time(findslash(2)+1:findslash(3)-1);

% load allen parcels
load('/gpfs/gibbs/project/higley/hd362/meso_code/MesoProcessing-master/allen_parcel/parcels_updated12522.mat', 'allen_parcels');
%load('parcells_updated121519.mat','parcells_new');
%load('brain_mask.mat','brain_mask');
load('parcel_obj.mat', 'parcel_obj')
brain_mask = parcel_obj.mask;

outputFolder = dir(fullfile(fixedOutputDir,id_date_time, '**', 'aligned'));
outputFolder = outputFolder.folder;
outputDir= fileparts(outputFolder);

hemoCorrectedFolder = fullfile(outputDir, 'hemoCorrectedSigDff');

% if ~strcmp(project, 'HD')
%     load(fullfile(outputDir, 'state_timestamps.mat'),'states');
%     load(fullfile(outputDir, 'final_timestamps.mat'),'spike2_data');
% end
% 
% if exist(fullfile(outputDir, 'tform.mat'), 'file')
%     load(fullfile(outputDir, 'tform.mat'),'tform','R','C');
%     disp('tform'); R=256; C=256;
% elseif exist(fullfile(outputDir, 'tform_blue.mat'), 'file')
%     load(fullfile(outputDir, 'tform_blue.mat'),'tform','R','C');
%     disp('tform_blue')
% end


% if exist(fullfile(outputDir, 'hemoCorrectedNoise'), 'dir')
%     delete(fullfile(outputDir, '/hemoCorrectedNoise/*'))
%     rmdir(fullfile(outputDir, 'hemoCorrectedNoise'))
% end


%% reconstruct hemo-corrected files

% get all files to read from data dir
files = dir(fullfile(hemoCorrectedFolder,'*.mat'));

% find indices that dont correspond to channel we are after
removeInds = [];
for i = 1:length(files)
    if ~contains(files(i).name,signalType,'IgnoreCase',true)
        removeInds(end+1) = i;
    end
end

% remove files not from channel of interest
files(removeInds) = [];

% peek at data to see how many samples were taken
peekData = load(fullfile(files(1).folder,files(1).name));
f = fields(peekData);
output_sig = nan(256,256,size(peekData.(f{1}),3));

% load data and determine column numbers from file name
for i = 1:length(files)
    if contains(files(i).name,signalType,'IgnoreCase',true)
        peekData = load(fullfile(files(i).folder,files(i).name));
        fileName = files(i).name;
        startInd = strfind(files(1).name,'Col');
        col = str2double(regexp(fileName(startInd:end),'\d*','Match'));
        colsIncluded = ((colPerBatch*col)-(colPerBatch-1)):(col*colPerBatch);
        output_sig(:,colsIncluded,:) = single(peekData.(f{1}));
    end
end

%output_sig = reshape(output_sig, 256*256, []);
%save(fullfile(outputDir, 'full_output.mat'),'output_sig', '-v7.3');

if exist(fullfile(outputDir, 'full_output.mat'), 'file')
    delete(fullfile(outputDir, 'full_output.mat'))
end

%% Alignment 

% movVar = var(output_sig(:, :, 501:end),[],3,'omitnan');
% lowPrctile = prctile(movVar(:),5);
% highPrctile = prctile(movVar(:),95);
% movVar(movVar<lowPrctile) = lowPrctile;
% movVar(movVar>highPrctile) = highPrctile;
% reactiveAllenAlignment(movVar)
% 
% tformFile = fullfile(fixedOutputDir, 'process', strcat('tform', mouseID, '.mat'));
% save(tformFile, 'tform');


%% Load tform.mat and transform the data
tformFile = fullfile(fixedOutputDir, 'process', strcat('tform', mouseID, '.mat'));

load(tformFile);
data_tform = transform_frames(output_sig,tform);

%% Use Mask to block out non brain pixels

mask = allen_parcels.CombinedParcells>0;

% mask points that don't fall on the brain and zscore those that do
for i =1:256
   data_tform(~mask(:,i),i,:) = nan;
   data_tform(mask(:,i),i,:) = normalize(data_tform(mask(:,i),i,:),3);
end

%% Parcellate the data

parcellated = parcels_by_Allen_atlas(reshape(data_tform,256^2,[]),allen_parcels);

parcelFile = strcat('parcellatedDff_', mouseID, '_', date, '.mat');
% save parcellated data
save(fullfile(outputDir, parcelFile),'parcellated')


%% Save the data_tform into mat

data_tformFile = strcat('NeuralDff_', mouseID, '_', date, '.mat');
save(fullfile(outputDir, data_tformFile), 'data_tform', '-v7.3')

%% write data into avi video
% Sample data (replace with your actual data)
data = data_tform;
% data = clips_mean;
% Define the range of pixel values you want to display
min_val = -2;  % Minimum pixel value to display
max_val = 2;  % Maximum pixel value to display

video_filename = fullfile(outputDir, strcat('NeuralDff_HC_R', num2str(max_val), '_', mouseID, '_', date));

%video_filename = 'W:\Hao\Globus\2024_11_04_15_29\clip_ave_v2'
% Create a VideoWriter object, specify the filename and frame rate
v = VideoWriter(video_filename);  % Specify the file name and format
v.FrameRate = 30;  % Set the frame rate to 30 Hz

% Open the video file for writing
open(v);

% Loop through each frame, adjust pixel values, and write to video
for i = 1:size(data, 3)
    frame = data(:, :, i);  % Extract the ith frame

    % Normalize the frame to the range [0, 1] based on the specified range
    adjusted_frame = (frame - min_val) / (max_val - min_val);

    % Clip values outside the range [0, 1]
    adjusted_frame(adjusted_frame < 0) = 0;
    adjusted_frame(adjusted_frame > 1) = 1;

    % Convert the adjusted frame to RGB using a colormap
    rgb_frame = ind2rgb(uint8(adjusted_frame * 255), colormap('parula'));

    % Write the RGB frame to the video
    writeVideo(v, rgb_frame);

end

% Close the video file
close(v);

disp('Video saved successfully.');

%%
% if strcmp(project, 'HD')
%     aligned = rot90(output_sig, -1);
%     aligned(brain_mask==0,:) = nan;
% 
% 
% % elseif strcmp(project, 'THAL')
% %     aligned = output_sig;
% 
% else
%     tic
%     disp('Aligning to template...');
% 
%     % these sessions need to be rotated 90 degrees prior to alignment
%     if strcmp(project, 'reProcessed_antara')
%         disp('project = reprocesed crispr things')
%         temp = reshape(output_sig, 256, 256, []);
%         temp1 = rot90(temp);
%         output_sig = reshape(temp1, 256*256, []);
%     end
% 
%     aligned = transform_frames(output_sig, tform, R, C);
% 
%     if exist(fullfile(outputDir, 'rotate.txt'),'file')==2
%         disp('project = reprocesed crispr things')
%         temp = reshape(output_sig, 256, 256, []);
%         temp1 = rot90(temp);
%         output_sig = reshape(temp1, 256*256, []);
%     end
% 
%     aligned = transform_frames(output_sig, tform, R, C);
% 
% 
%     % these sessions need to be rotated 180 degrees after alignment
%     if strcmp(project, 'Courtney')
%         disp('project = courtney')
%         temp = reshape(aligned, 256, 256, []);
%         temp1 = rot90(temp, 2);
%         aligned = reshape(temp1, 256*256, []);
%     end
% 
%     aligned(brain_mask==0,:) = nan;
%     disp(['Aligning to atlas: ' num2str(toc)])
% 
% end
% 
% 
% %% clip of hemo corrected output
% 
% filename = fullfile(outputDir, 'hemoOutput.gif');
% % meso_clip(aligned, filename, 1400:1500, 'smoothed_no')
% meso_clip(aligned, filename, 600:700, 'smoothed_no')
% 
% 
% %% need to fix timestamp data for some of antara's sessions
% % 
% % if exist(fullfile(outputDir, 'antara_timestamp_fix.txt'),'file')==2
% % 
% %     load(fullfile(outputDir, 'final_timestamps.mat'), 'spike2_data');
% %     load(fullfile(outputDir, 'facecam_motion_energy.mat'), 'vid_energy');
% %     facemap = [vid_energy; zeros(27, 1)];
% % 
% %     face_time = spike2_data.pupilFrameOnTimestamps;
% %     behavior_end_time = face_time(end);
% %     imaging_time = spike2_data.blueOnTimestamps;
% %     imaging_end_time = imaging_time(end);
% % 
% %     min_time = min(imaging_end_time, behavior_end_time);
% %     behavior_end_ind = findClosestDouble(face_time, min_time);
% %     imaging_end_ind = findClosestDouble(imaging_time, min_time);
% % 
% %     face_time = face_time(1:behavior_end_ind);
% %     imaging_time = imaging_time(1:imaging_end_ind);
% % 
% %     maxLength = min(length(face_time), length(imaging_time));
% %     face_time = face_time(end-maxLength+1:end);
% %     imaging_time = imaging_time(end-maxLength+1:end);
% % 
% %     wheel_end_ind = findClosestDouble(spike2_data.analog_signal_time_vect, min_time);
% %     wheel_start_ind = findClosestDouble(spike2_data.analog_signal_time_vect, imaging_time(1));
% %     wheel_time = spike2_data.analog_signal_time_vect(wheel_start_ind:wheel_end_ind);
% %     wheel_speed = spike2_data.wheelSpeed(wheel_start_ind:wheel_end_ind);
% % 
% %     spike2_data.pupilFrameOnTimestamps = face_time;
% %     spike2_data.blueOnTimestamps = imaging_time;
% %     spike2_data.analog_signal_time_vect = wheel_time;
% %     spike2_data.wheelSpeed = wheel_speed;
% % 
% %     states = newStates(spike2_data, facemap, 2, 3, 10);
% %     save(fullfile(outputDir, 'state_timestamps.mat'), 'states', '-v7.3');
% % 
% %     behavior = newStates(spike2_data, facemap, 2, 0, 0);
% %     save(fullfile(outputDir, 'behavior_timestamps.mat'), 'behavior', '-v7.3');
% % 
% %     statesplot = states_fig(states, spike2_data, facemap, '', id_date_time);
% %     saveas(statesplot, fullfile(outputDir, 'statesplot'));
% % 
% % end
% 
% %% normalization
% 
% switch norm_method
%     case 'none'% do nothing
%         normed_sig = aligned;
% 
%     case 'zscored' %redoes zscore and then does dff
%         [normed_sig, ~, ~] = zscore_pixelwise(aligned, delay_length);
% 
%     case 'dff' %finds df/f using mean of bottom 10% as f0
%         [normed_sig] = dff_bottom10(aligned);
% 
%     case 'lowface10p'
%         if isfield(spike2_data, 'blueOnTimestamps')
%             mesoTimestampsOn = spike2_data.blueOnTimestamps; 
%         else
%             mesoTimestampsOn = spike2_data.greenOnTimestamps; 
%         end
%         [normed_sig, F0, ~] = lowfaceNorm_bottom10(states, mesoTimestampsOn, aligned);
%         f0_fig = figure();
%         imagesc(reshape(F0, 256, 256));
%         saveas(f0_fig, fullfile(outputDir, 'f0.png'))
% 
%     otherwise
%         error('Illeagal Normalization method');
% end
% 
%     normalized = fullfile(outputDir, ['normed_' norm_method '_blue_uv.mat']);
%     save(normalized, 'normed_sig', '-v7.3'); % save time trace both w and without mean removal
% 
% 
%     disp('Normalization complete')
% 
% 
% 
% %% save short clip for confirming output
% 
% filename = fullfile(outputDir, 'confirmOutput.gif');
% %meso_clip(normed_sig, filename, 1400:1500, 'smoothed_no')
% meso_clip(normed_sig, filename, 600:700, 'smoothed_no')
% 
% 
% %% save short clip for confirming output (smoothed)
% 
% filename = fullfile(outputDir, 'confirmOutput_sm.gif');
% meso_clip(normed_sig, filename, 600:700, 'smoothed_yes')
% 
% 
% %% Parcellation: 'allen'
% 
% brain_mask_new = brain_mask;
% brain_mask_new(:, 119:138) = false;
% brain_mask_new = reshape(brain_mask_new, 256*256, []);
% normed_sig(~brain_mask_new, :) = NaN;
% parcels_time_trace = parcellate_allen(parcells_new, normed_sig);
% 
% allenfile = fullfile(outputDir,  ['Ca_traces_spt_patch9_' norm_method '_Allen.mat']); %find me: _Allen_dffnorm.mat
% save(allenfile, 'parcels_time_trace'); % save time trace both w and without mean removal
% disp('Allen parcellation complete')
% 
% 
% %% Parcellation: 'allen'(for nonnormed data...)
% 
% aligned(~brain_mask_new, :) = NaN;
% parcels_time_trace = parcellate_allen(parcells_new, aligned);
% save(fullfile(outputDir,  'nonnormed_parcels'), 'parcels_time_trace'); % save time trace both w and without mean removal
% 
% disp('Allen parcellation of nonnormed data complete')
% 
% 
% %% Parcellation: 'LSSC'
% 
% % 
% % % remove the mid-line
% % [R,C] = size(brain_mask);
% % brain_mask(:, 121:134) = false; %previously: 125:131
% % brain_mask_left = brain_mask;
% % brain_mask_right = brain_mask;
% % brain_mask_left(:,129:end) = false;
% % brain_mask_right(:,1:128) = false;
% % 
% % % we parcellate left and right separately
% % cfg.outputfilepath = outputDir;
% % cfg.preProcess=false;
% % cfg.N_TRIALS=10;
% % cfg.n_clust = 5000 ;
% % cfg.makePlots = false;
% % cfg.thrcluster=0.99; % change this to influence number of parcels; can give a vector of different threshold (e.g. [0.9:0.01:0.99])
% % cfg.NROWS = R;
% % cfg.NCOLS = C;
% % cfg.isoverlap = false;
% % 
% % tic
% % allregionspix_left = find(brain_mask_left);
% % dFoF_masked_left = normed_sig(allregionspix_left, :);
% % st=1e3;en=size(dFoF_masked_left,2)-1e3;
% % cfg.title_str ='left_LSSC';
% % warning('off', 'MATLAB:eigs:IgnoredOptionIssym');
% % runROI_meso_nlm(cfg, dFoF_masked_left(:,st:en), allregionspix_left, brain_mask_left);
% % clear dFoF_masked_left brain_mask_left allregionspix_left
% % disp(['left lssc done: ' num2str(toc) 's'])
% % 
% % tic
% % allregionspix_right = find(brain_mask_right);
% % dFoF_masked_right = normed_sig(allregionspix_right, :);
% % st=1e3;en=size(dFoF_masked_right,2)-1e3;
% % cfg.title_str ='right_LSSC';
% % runROI_meso_nlm(cfg, dFoF_masked_right(:,st:en), allregionspix_right, brain_mask_right);
% % clear dFoF_masked_right brain_mask_right allregionspix_right
% % disp(['right lssc done: ' num2str(toc) 's'])
% % 
% % tic
% % leftfile = dir(fullfile(outputDir, 'left_LSSC*.mat'));
% % parleft = load(fullfile(leftfile.folder, leftfile.name));
% % rightfile = dir(fullfile(outputDir, 'right_LSSC*.mat'));
% % parright = load(fullfile(rightfile.folder, rightfile.name));
% % parcelsAll = [parleft.ROI_list parright.ROI_list];
% % 
% % parmap = zeros(R,C);
% % parcels_time_trace = zeros(length(parcells_new.names), size(normed_sig,2), 'single');
% % 
% % for par_i = 1:length(parcelsAll)
% %     roiinds=parcelsAll(par_i).pixel_list;
% %     parmap(roiinds) = par_i;
% % 
% %     pardata = normed_sig(roiinds, :);
% %     parcels_time_trace(par_i,:) = mean(pardata, 'omitnan');
% % 
% % end
% % disp(['making map: ' num2str(toc) 's'])
% % 
% % tic
% % galfile = fullfile(outputDir,  ['Ca_traces_spt_patch9_' norm_method '_LSSC.mat']); %find me: _Allen_dffnorm.mat
% % save(galfile, 'parcels_time_trace', 'parmap'); % 'parcels_time_trace_GSR',
% % disp(['saving lssc: ' num2str(toc) 's'])
% % 
% % tic
% % delete(fullfile(leftfile.folder, leftfile.name))
% % delete(fullfile(rightfile.folder, rightfile.name))
% % close all
% % disp(['deleting unnecessary files: ' num2str(toc) 's'])
% % 
% % disp('LSSC parcellation complete')
% 
% %% Parcellation: Grids
% 
% load("grid_obj.mat", 'grid_obj')
% num_grid_parcels = size(grid_obj.indicators, 2);
% 
% parcels_time_trace = zeros(num_grid_parcels, size(normed_sig,2), 'single');
% for par_i = 1:num_grid_parcels
% 
%     roiinds = grid_obj.indicators(:,par_i) == 1;
%     pardata = normed_sig(roiinds, :);
%     detect = isoutlier(pardata);
%     keep_data = nan(size(pardata));
%     keep_data(detect==0) = pardata(detect==0);
%     parcels_time_trace(par_i,:) = mean(keep_data, 'omitnan');
% 
% end
% 
% gridfile = fullfile(outputDir,  ['Ca_traces_spt_patch9_' norm_method '_Grid4.mat']);
% save(gridfile, 'parcels_time_trace');
% clear parcels_time_trace
% 
% disp('grids parcellation complete')
% 
% %% CRF plots
% 
% if exist(fullfile(outputDir, 'stim_order.mat'), 'file')
% 
%     load(fullfile(outputDir, 'final_timestamps.mat'), 'spike2_data');
%     load(fullfile(outputDir, 'state_timestamps.mat'), 'states');
%     load(allenfile, 'parcels_time_trace');
%     load(fullfile(outputDir, 'stim_order.mat'), 'contrasts')
%     contrast_vals = unique(contrasts);
%     stims_per_contrast = length(contrasts)/length(unique(contrasts));
%     if isfield(spike2_data, 'blueOnTimestamps')
%         mesoOn = spike2_data.blueOnTimestamps;
%     else
%         mesoOn = spike2_data.greenOnTimestamps;
%     end
%     visOn = spike2_data.diodeOnTimestamps;
%     preSeconds = 2; postSeconds = 5; fs = 10;
%     t = -preSeconds:(preSeconds+postSeconds)/(preSeconds*fs+postSeconds*fs):postSeconds;
%     response_interval = (preSeconds*fs)+1:(1*fs)+(preSeconds*fs); %for 1s post-stim onset
% 
%     [alignedData, ~] = averageMovieToEvent(parcels_time_trace, mesoOn, visOn, preSeconds*fs, postSeconds*fs);
% 
%     % zscore each trace based on m and sd of pre stimulus
%     pre_traces = alignedData(:, :, 1:(preSeconds*fs));
%     pre_traces_mean = mean(pre_traces, 3, 'omitnan');
%     pre_traces_sd = std(pre_traces, 0, 3, 'omitnan');
%     alignedData_z = (alignedData - pre_traces_mean)./pre_traces_sd;
% 
%     aligned_traces = nan(stims_per_contrast, length(t)-1, length(contrast_vals));
%     for i = 1:length(contrast_vals)
%         contrast_inds = contrasts==contrast_vals(i);
%         if sum(contrast_inds)>0
%             aligned_traces(:,:,i) = squeeze(alignedData_z(contrast_inds, 2, :)); %change between 1 and 2 for left or right v1
%         else
%             aligned_traces(:,:,i) = nan(stims_per_contrast, length(t)-1);
%         end
%     end
% 
%     [~, loco] = calc_crf_responses(contrasts, parcels_time_trace, spike2_data, states);
%     new_loco = reshape_loco(loco, t);
% 
%     v1_aligned_traces_loco = nan(size(aligned_traces));
%     v1_aligned_traces_loco(new_loco==1) = aligned_traces(new_loco==1); %size = stims x time x contrasts
% 
%     v1_loco_responses = v1_aligned_traces_loco(:, response_interval, :); %size = stims x time x contrasts
%     v1_loco_trace_means = squeeze(mean(v1_loco_responses, 2)); %size = stims x contrasts (mean responses for each stim)
%     v1_loco_Mean = mean(v1_loco_trace_means, 1, 'omitnan');
%     v1_loco_SE = std(v1_loco_trace_means, 0, 1, 'omitnan')./sqrt(size(v1_loco_trace_means, 1));
% 
%     crf_plot = figure(); hold on;
%     shadedErrorBar(contrast_vals, v1_loco_Mean, v1_loco_SE, 'lineprops', {'k', 'markerfacecolor','k'});
%     plot((contrast_vals), squeeze(v1_loco_Mean), 'ko')
%     xlabel('contrast value'); ylabel('mean v1 response'); title('Contrast response function')
%     exportgraphics(crf_plot, fullfile(outputDir, 'crf_plot.pdf'),'ContentType','vector')
% 
% 
%     % get 100p trace
%     trace_100p = squeeze(v1_aligned_traces_loco(:,:,7));
%     trace_100p_mean = mean(trace_100p, 1, 'omitnan');
% 
%     trace_100p_fig = figure(); hold on;
%     plot(t(2:end), trace_100p_mean); xline(0)
%     exportgraphics(trace_100p_fig, fullfile(outputDir, 'trace_100p_loco.pdf'),'ContentType','vector')
% 
%     % also want 100p contrast full movie...
%     stims_100p = find(contrasts==100);
%     stim_times = spike2_data.diodeOnTimestamps(stims_100p);
%     [~, loco] = calc_crf_responses(contrasts, parcels_time_trace, spike2_data, states);
%     loco_keep = find(loco(7,:)==1);
% 
%     [alignedData, ~] = averageMovieToEvent(normed_sig, mesoOn, stim_times, preSeconds*fs, postSeconds*fs);
%     aligned_loco = alignedData(loco_keep, :, :);
%     aligned_mean = squeeze(mean(aligned_loco, 1, 'omitnan'));
%     pre_traces = aligned_mean(:, 1:(preSeconds*fs));
%     pre_traces_mean = mean(pre_traces, 2, 'omitnan');
%     pre_traces_sd = std(pre_traces, 0, 2, 'omitnan');
%     alignedData_z = (aligned_mean - pre_traces_mean)./pre_traces_sd;
%     save(fullfile(outputDir, 'avg_normed_100p.mat'), "alignedData_z");
% 
%     % gif of 100p response
%     filename = fullfile(outputDir, 'response_100p.gif');
%     meso_clip(alignedData_z, filename, 1:size(alignedData_z,2), 'smoothed_no')
% 
% 
% end
% 
% 
% %% sanity figs
% 
% % % define tings and load things needed for making figs
% % 
% % load(allenfile, 'parcels_time_trace');
% % load(fullfile(outputDir, 'facecam_motion_energy.mat'), 'vid_energy');
% % 
% % if isfield(spike2_data, 'blueOnTimestamps')
% %     mesoTimestampsOn = spike2_data.blueOnTimestamps;
% % else
% %     mesoTimestampsOn = spike2_data.greenOnTimestamps;
% % end
% % 
% % wheel_fs = 5000; imaging_fs = 10; preSeconds = 2; postSeconds = 6;
% % locoOn = states.locoOn-3;
% % whiskOn = states.faceHighSitOn;
% % 
% % 
% % % wheel and meso alignment check
% % sanityCheck = figure();
% % ax(1) = subplot(211);
% % plot(spike2_data.analog_signal_time_vect, spike2_data.wheelSpeed);
% % ylabel('wheel speed'); title(['alignment check - ' id_date_time], 'Interpreter', 'none');
% % ax(2) = subplot(212);
% % maxLength = min(length(mesoTimestampsOn), size(parcels_time_trace, 2));
% % plot(mesoTimestampsOn(1:maxLength), mean(parcels_time_trace(:, 1:maxLength),1, 'omitnan'));
% % ylabel('mean(all parcels)'); xlabel('LEDonTimestamps (seconds)'); linkaxes(ax,'x');
% % saveas(sanityCheck, fullfile(outputDir, 'alignmentCheck'));
% % 
% % 
% % 
% % 
% % % getting data for state-dep activity
% % if size(spike2_data.wheelSpeed, 1) > 1; spike2_data.wheelSpeed = spike2_data.wheelSpeed'; end
% % [alignedData, ~] = averageMovieToEvent(spike2_data.wheelSpeed, spike2_data.analog_signal_time_vect, locoOn, preSeconds*wheel_fs, postSeconds*wheel_fs);
% % aligned_zscored = zscore(squeeze(alignedData), [], 2);
% % baseline_means = mean(aligned_zscored(:,1:preSeconds*wheel_fs), 2);
% % aligned_zscored_baselinesub = aligned_zscored - baseline_means;
% % avgWheelOnset = squeeze(mean(aligned_zscored_baselinesub,1, 'omitnan'));
% % 
% % [alignedData, ~] = averageMovieToEvent(vid_energy', spike2_data.pupilFrameOnTimestamps, whiskOn, preSeconds*imaging_fs, postSeconds*imaging_fs);
% % aligned_zscored = zscore(squeeze(alignedData), [], 2);
% % if size(aligned_zscored, 2)>1
% %     baseline_means = mean(aligned_zscored(:,1:preSeconds*imaging_fs), 2);
% %     aligned_zscored_baselinesub = aligned_zscored - baseline_means;
% %     avgWhiskOnset = squeeze(mean(aligned_zscored_baselinesub,1, 'omitnan'));
% % else
% %     baseline_means = mean(aligned_zscored(1:preSeconds*imaging_fs, :), 1);
% %     aligned_zscored_baselinesub = aligned_zscored' - baseline_means;
% %     avgWhiskOnset = squeeze(mean(aligned_zscored_baselinesub,1, 'omitnan'));
% % end
% % 
% % [alignedData, ~] = averageMovieToEvent(parcels_time_trace(1,:), mesoTimestampsOn, locoOn, preSeconds*imaging_fs, postSeconds*imaging_fs);
% % aligned_zscored = zscore(squeeze(alignedData), [], 2);
% % baseline_means = mean(aligned_zscored(:,1:preSeconds*imaging_fs), 2);
% % aligned_zscored_baselinesub = aligned_zscored - baseline_means;
% % avgLocoActivity = squeeze(mean(aligned_zscored_baselinesub,1, 'omitnan'));
% % 
% % [alignedData, ~] = averageMovieToEvent(parcels_time_trace(1,:), mesoTimestampsOn, whiskOn, preSeconds*imaging_fs, postSeconds*imaging_fs);
% % aligned_zscored = zscore(squeeze(alignedData), [], 2);
% % if size(aligned_zscored, 2)>1
% %     baseline_means = mean(aligned_zscored(:,1:preSeconds*imaging_fs), 2);
% %     aligned_zscored_baselinesub = aligned_zscored - baseline_means;
% %     avgWhiskActivity = squeeze(mean(aligned_zscored_baselinesub,1, 'omitnan'));
% % else
% %     baseline_means = mean(aligned_zscored(1:preSeconds*imaging_fs, :), 1);
% %     aligned_zscored_baselinesub = aligned_zscored' - baseline_means;
% %     avgWhiskActivity = squeeze(mean(aligned_zscored_baselinesub,1, 'omitnan'));
% % end
% % 
% % 
% % % state-dep activity plot
% % state_activity_plot = figure(); hold on
% % ax(1) = subplot(2, 2, 1); plot(avgWheelOnset); title('avg loco Onset'); xline(10000); ylim([-1 4])
% % ax(2) = subplot(2, 2, 2); plot(avgWhiskOnset); title('avg whisk Onset'); xline(20); ylim([-1 4])
% % ax(3) = subplot(2, 2, 3); plot(avgLocoActivity); title('v1 activity at loco onset'); xline(20); ylim([-1 4])
% % ax(4) = subplot(2, 2, 4); plot(avgWhiskActivity); title('v1 activity at whisk onset'); xline(20); ylim([-1 4])
% % saveas(state_activity_plot, fullfile(outputDir, 'state_check.fig'));
% 
% 
% 
% %% done
% 
% disp('sanity figures complete')
fprintf([id_date_time ' finished processing at %s\n'], datestr(now,'HH:MM:SS.FFF'))


end



